#pragma once

#include <iostream>
#include <vector>

class Node
{
public:
	// Конструкторы (по умолчанию и с параметрами)
	Node();
	Node(int key);
	Node(int key, Node* left, Node* right);
	// Деструктор
	~Node();
	// Получение/изменение ключа узла (целое число)
	int getKey() const;
	void setKey(int key);
	// Получение/изменение потомков узла
	Node* getLeft() const;
	Node* getRight() const;
	void setLeft(Node* left);
	void setRight(Node* right);
private:
	int key;
	Node* left;
	Node* right;
};

class BinaryTree
{
public:
	// Конструкторы (по умолчанию, копирования, перемещения)
	BinaryTree();
	BinaryTree(const BinaryTree& other);
	BinaryTree(BinaryTree&& other) noexcept;
	// Деструктор
	~BinaryTree();
	// Получение корня дерева
	Node* getRoot() const;
	// Очистка дерева (удаление всех узлов)
	void clear();
	// Удаление поддеревьев узла
	void removeSubtrees(Node* node);
	// IsEmpty (возвращает true, если дерево пусто)
	bool isEmpty() const;
	// Получение высоты дерева
	// Получение количества узлов дерева
	// Получение минимального/максимального ключа дерева
	// Добавление узла в дерево (методом случайного выбора поддерева)
	// Удаление узла из дерева по ключу (возвращает true, если узел был удалён)
	// Поиск узла дерева по ключу
	// Проверка дерева на сбалансированность (возвращает true, если дерево является сбалансированным: высоты правого и левого поддеревьев отличаются не более, чем на единицу, и сами поддеревья также являются сбалансированными)
	// Получение уровня вершины по ключу (возвращает индекс уровня или -1, если вершина не найдена)
	// Получение вектора (std::vector<int>), содержащего все ключи дерева по возрастанию (обход вершин производить любым способом)
	// Вывод в консоль дерева в горизонтальном виде (самый правый потомок находится на первой строке, самый левый - на нижней)
	// Вывод в консоль дерева по уровням в консоль
	// Оператор присваивания
	// Оператор перемещения
private:
	// Вспомогательные методы
	void destroyTree(Node* node);
	Node* copyTree(const Node* node);
private:
	Node* root;
};